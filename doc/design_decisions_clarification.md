# AgentTalk 设计决策澄清文档

## 文档信息

- **文档名称**：设计决策澄清（Design Decisions Clarification）
- **版本**：v1.0
- **创建日期**：2025-01-05
- **目的**：记录通过讨论澄清的核心设计决策，解决逻辑自洽性问题

---

## 一、权限系统

### 决策1：权限是固定的

**问题**：Agent的权限是固定的还是可以通过学习动态获得？

**决策**：✅ **权限是固定的**

**说明**：
- Agent的权限不会动态变化
- 权限通过"技能"来定义
- 拥有某个技能 = 拥有对应的权限
- Agent不能通过"学习"获得新的权限权限

**示例**：
```
技能：召集会议
权限：
  - 可以发起会议
  - 可以邀请参与者
  - 可以生成会议纪要

拥有此技能的Agent：
  - 总经理
  - 项目经理
  - 技术经理
  - 其他经理/主管

不拥有此技能的Agent：
  - Excel专家
  - 爬虫专家
  - 其他专家Agent
```

---

### 决策2：权限通过技能区分

**问题**："所有Agent平等"与"层级权限"如何统一？

**决策**：✅ **Agent在技术架构上平等，但功能权限通过技能区分**

**说明**：
- **技术层面**：所有Agent都是独立的实例，架构上平等
- **功能层面**：通过不同的技能组合实现不同的角色和权限

**示例**：
```python
# 所有Agent都是平等的实例
class Agent:
    def __init__(self, agent_id, skills):
        self.agent_id = agent_id
        self.skills = skills  # 技能决定权限

# 不同Agent有不同技能
general_manager = Agent("gm", [skill_assign_no_tag, skill_convene_meeting])
tech_manager = Agent("tm", [skill_assign_tech_tag, skill_convene_meeting])
excel_expert = Agent("excel", [skill_excel_process])  # 无分配技能
```

**关键点**：
- 不是"Agent有不平等的地位"
- 而是"Agent有不同的能力（技能）"
- 权限是能力的自然体现

---

## 二、会议召集机制

### 决策3：有"召集会议"技能的Agent都能召集会议

**问题**：谁有资格召集会议？

**决策**：✅ **拥有"召集会议"技能的Agent都可以召集会议**

**召集权限分级**：

| Agent类型 | 召集权限 | 会议特点 |
|-----------|---------|---------|
| **总经理** | ✅ 可以召集 | 可以召集**无标签任务**的会议 |
| **项目经理** | ✅ 可以召集 | 只能召集**项目标签**任务的会议 |
| **技术经理** | ✅ 可以召集 | 只能召集**技术标签**任务的会议 |
| **产品经理** | ✅ 可以召集 | 只能召集**产品标签**任务的会议 |
| **专家Agent** | ❌ 不能召集 | 只能参加会议，不能召集 |

**区别说明**：
- **总经理**：特殊权限，能处理任何标签的任务（包括无标签）
- **其他经理**：只能处理特定标签的任务
- **专家**：只能执行任务，不能召集会议

**示例场景**：
```
场景1：无标签任务
用户任务："帮我做一个网站"
↓
总经理召集会议（因为任务没有标签）
参会者：项目经理 + 技术经理 + 产品经理

场景2：技术任务
技术经理收到："开发Excel导入功能"
↓
技术经理召集会议（因为任务是技术标签）
参会者：后端专家 + 前端专家 + 数据库专家

场景3：专家发起协作
后端专家需要数据库专家协助
↓
后端专家**不能召集会议**
↓
后端专家发送"求助文件"给技术经理
↓
技术经理判断后转发或上报
```

**关键设计**：
- 召集会议 ≠ 分配任务
- 召集会议是"组织讨论"
- 分配任务是"下达指令"
- 两者是不同的技能

---

## 三、时间维度设计

### 决策4：LLM会议不需要快速响应

**问题**：会议的实时性要求是什么？

**决策**：✅ **LLM会议可以慢速进行，不需要实时响应**

**时间设计**：

| 活动 | 时间尺度 | 说明 |
|------|---------|------|
| **文件轮询** | 10秒一次 | Agent检查收件箱的频率 |
| **单轮消息** | 10-30秒 | Agent处理消息并发送响应 |
| **单次会议** | 几小时到几天 | 不限制会议时长 |
| **任务执行** | 几分钟到几周 | 根据任务复杂度 |

**会议节奏示例**：
```
T+0分钟：总经理发起会议
T+10秒：技术经理检查收件箱，发现邀请
T+30秒：技术经理准备输入并回复
T+1分钟：产品经理检查收件箱，发现邀请
T+2分钟：产品经理回复
...（持续进行）
T+2小时：会议达成共识，产出任务分配清单
```

**关键点**：
- 会议不需要所有Agent同时在线
- Agent可以异步参与会议
- 会议可以跨越多个轮询周期
- 允许Agent有"离线时间"

**设计理念**：
> "会议是持续的协商过程，而不是瞬间的决定"
> 类似于电子邮件讨论链，而不是实时聊天

---

### 决策5：文件通信轮询频率为10秒

**问题**：Agent多久检查一次收件箱？

**决策**：✅ **每10秒检查一次**

**说明**：
- 每个Agent独立运行一个轮询循环
- 每10秒检查自己的收件箱
- 如果有新消息，立即处理
- 如果没有新消息，休眠10秒

**伪代码**：
```python
while agent_is_running:
    new_messages = check_inbox()
    if new_messages:
        for message in new_messages:
            process_message(message)
    sleep(10_seconds)
```

**性能考虑**：
- 10秒轮询 = 每天检查8,640次
- 50个Agent = 每天约432,000次文件检查
- 文件操作很快（<1ms），性能可接受

**优化空间**（未来）：
- 使用文件系统监控事件（inotify/FSEvents）
- 降低轮询频率到30秒或60秒
- 实现"休眠唤醒"机制

---

## 四、求助机制（核心创新）

### 决策6：通过"求助"而非"分配"实现底层协作

**问题**：专家Agent发现需要其他专家协助时怎么办？

**决策**：✅ **专家使用"求助机制"，而非"任务分配"**

**核心设计**：
- **分配任务**：有"分配"技能的Agent（经理+）向下发任务
- **请求协助**：没有"分配"技能的Agent（专家）向上求助

**求助流程**：

```
Level 1: 专家发现问题
┌─────────────────────────────────────┐
│ 后端专家发现需要数据库专家协助      │
│ ↓                                   │
│ 制作求助文件                         │
│   - message_type: "HELP_REQUEST"    │
│   - required_input: ...             │
│   - expected_output: ...            │
│   - return_address: 自己的agent_id   │
│ ↓                                   │
│ 发送给技术经理（自己的标签经理）     │
└─────────────────────────────────────┘

Level 2-A: 技术经理能解决
┌─────────────────────────────────────┐
│ 技术经理收到求助                    │
│ ↓                                   │
│ LLM分析："这是数据库相关，我能处理"  │
│ ↓                                   │
│ 直接转发给数据库专家（带上return_address）│
│ ↓                                   │
│ 数据库专家处理任务                   │
│ ↓                                   │
│ 完成后直接回复给后端专家             │
│   - to_agent: return_address        │
└─────────────────────────────────────┘

Level 2-B: 技术经理不能解决
┌─────────────────────────────────────┐
│ 技术经理收到求助                    │
│ ↓                                   │
│ LLM分析："这需要产品决策，超出范围"  │
│ ↓                                   │
│ 发送给总经理（带上return_address）   │
│ ↓                                   │
│ 总经理LLM分析："应该找产品经理"     │
│ ↓                                   │
│ 转发给产品经理                      │
│ ↓                                   │
│ 产品经理转发给对应专家              │
│ ↓                                   │
│ 专家完成后回复给后端专家             │
└─────────────────────────────────────┘
```

---

### 决策7：求助文件包含返回地址

**问题**：专家如何知道将结果回复给谁？

**决策**：✅ **求助文件中包含return_address字段**

**求助文件格式**：
```json
{
  "message_id": "msg_20250105_123456_001",
  "message_type": "HELP_REQUEST",
  "from_agent": "agent_301_backend_expert",
  "to_agent": "agent_002_tech_manager",
  "timestamp": "2025-01-05T12:34:56Z",

  "help_request": {
    "required_input": "用户上传的Excel文件",
    "expected_output": "数据库表结构设计",
    "context": "我正在开发Excel导入功能，需要数据库表设计",
    "tags": ["数据库", "设计"]
  },

  "return_address": "agent_301_backend_expert"
}
```

**关键设计**：
- `return_address`: 原始请求者的agent_id
- 这个地址会一路传递下去
- 最终执行者直接回复给return_address

**传递链路**：
```
后端专家(return_address="agent_301")
  → 技术经理(转发，保留return_address)
    → 数据库专家(读取return_address)
      → 直接回复给 agent_301_backend_expert
```

---

### 决策8：技术经理使用LLM分析求助

**问题**：技术经理如何判断"能解决"还是"需要上报"？

**决策**：✅ **技术经理使用LLM分析求助内容**

**判断逻辑**：

```python
# 技术经理收到求助
message = receive_message()

# LLM分析
analysis = llm_analyze(
    prompt=f"""
    你是技术经理，收到以下求助请求：

    求助内容：{message.help_request}
    求助标签：{message.help_request.tags}
    你能分配的标签：{my_assignable_tags}  # ["技术", "后端", "前端"]

    请判断：
    1. 这个求助是否在你的能力范围内？
    2. 如果是，应该转发给哪个专家？
    3. 如果不是，应该上报给谁？

    输出JSON格式：
    {{
      "can_handle": true/false,
      "reason": "...",
      "action": "forward/escalate",
      "target_agent": "agent_xxx"
    }}
    """
)

# 根据分析结果执行
if analysis.can_handle:
    forward_to(analysis.target_agent, message)
else:
    escalate_to(general_manager, message)
```

**示例场景**：

**场景1：技术经理能处理**
```
求助内容：需要数据库表设计
技术经理LLM分析：
  - 标签是"数据库"
  - 我能分配"技术"标签的任务
  - 数据库设计属于技术范畴
  - 我有"数据库专家"可以分配

判断结果：can_handle = true
操作：转发给数据库专家
```

**场景2：技术经理不能处理**
```
求助内容：需要用户界面设计建议
技术经理LLM分析：
  - 标签是"设计"
  - 我只能分配"技术"标签的任务
  - 设计不属于我的范畴
  - 我没有"设计专家"可以分配

判断结果：can_handle = false
操作：上报给总经理
```

---

### 决策9：求助格式暂时不考虑技术细节

**问题**：求助文件的具体格式是什么？

**决策**：✅ **格式细节在技术设计阶段确定，现在只关注业务流程**

**当前定义的字段**：
- `message_type`: "HELP_REQUEST"（消息类型）
- `help_request`: {required_input, expected_output, context, tags}（求助内容）
- `return_address`: 原始请求者的agent_id（返回地址）

**待技术设计阶段确定**：
- 具体的JSON schema
- 必填字段vs可选字段
- 字段验证规则
- 附件处理方式

**原则**：
> 业务逻辑先行，技术细节后补
> 先确保流程正确，再优化数据格式

---

## 五、服务路由机制

### 决策10：三层路由架构

**问题**：如何实现高效的资源发现和路由？

**决策**：✅ **三层路由架构**

```
┌─────────────────────────────────────────┐
│           Layer 1: 专家层               │
│  ┌──────────┐  ┌──────────┐             │
│  │后端专家  │  │数据库专家│             │
│  └────┬─────┘  └──────────┘             │
│       │                                  │
│       │ 求助                             │
│       ↓                                  │
│ ┌──────────────────────────────────────┐ │
│ │     Layer 2: 经理层（路由层）        │ │
│ │  ┌────────┐  ┌────────┐  ┌────────┐ │ │
│ │  │技术经理│  │产品经理│  │设计经理│ │ │
│ │  └───┬────┘  └───┬────┘  └───┬────┘ │ │
│ │      │不能解决   │           │       │ │
│ └──────┼──────────┼───────────┼───────┘ │
│         │上报      │           │         │
│         └──────────┴───────────┘        │
│                    ↓                    │
│ ┌──────────────────────────────────────┐ │
│ │   Layer 3: 总经理层（全局路由）      │ │
│ │          ┌──────────┐                │ │
│ │          │ 总经理   │                │ │
│ │          └────┬─────┘                │ │
│ └───────────────┼──────────────────────┘ │
│                 │ 跨部门路由             │
└─────────────────┼───────────────────────┘
                  ↓
              找到对应经理
                  ↓
              转发给对应专家
```

**路由规则**：

| 当前层 | 目标 | 路由路径 |
|--------|------|---------|
| 专家 | 其他专家 | 上报给自己的经理 |
| 经理 | 自己的专家 | 直接转发（2跳） |
| 经理 | 其他部门的专家 | 上报给总经理（3-4跳） |
| 总经理 | 任何专家 | 转发给对应经理，再转发给专家 |

**路由效率**：
- **最短路径**：2跳（专家→经理→专家）
- **最长路径**：4跳（专家→经理→总经理→经理→专家）
- **平均路径**：2-3跳

---

## 六、解决的核心矛盾

### 矛盾1：Agent平等性 vs 层级权限 ✅ 已解决

**原问题**：
- 说法A："所有Agent本质上平等"
- 说法B："只有总经理能分配无标签任务"

**解决方案**：
- "平等"指**技术架构平等**（都是独立实例）
- "权限"指**功能能力不同**（通过技能区分）
- 不是地位不平等，而是能力有差异

**类比**：
- 公司里的员工都是平等的（人格上）
- 但职位和能力不同（功能上）
- CEO和实习生都能说话，但决策权不同

---

### 矛盾2：会议召集权限模糊 ✅ 已解决

**原问题**：
- 谁有资格召集会议？
- 只有总经理？还是经理也能？

**解决方案**：
- 有"召集会议"技能就能召集
- 召集权限通过标签区分
  - 总经理：无标签会议
  - 经理：特定标签会议

**示例**：
```
总经理：能召集任何主题的会议
技术经理：只能召集技术相关的会议
产品经理：只能召集产品相关的会议
```

---

### 矛盾3：任务分解的递归问题 ✅ 已解决

**原问题**：
- 后端专家发现需要数据库专家协助
- 但后端专家没有"分配任务"技能
- 怎么办？

**解决方案**：
- 不使用"分配"，使用"求助"
- 求助机制是**向上请求**，不是"向下分配"
- 经理层承担路由和协调职责

**核心区别**：
| 分配任务 | 求助协助 |
|---------|---------|
| 向下级发指令 | 向上级请求支持 |
| 需要分配技能 | 不需要分配技能 |
| 命令式 | 协商式 |
| 经理→专家 | 专家→经理→专家 |

---

### 矛盾4：会议与通信延迟 ✅ 已解决

**原问题**：
- LLM会议需要多轮对话
- 文件通信是异步的（10秒轮询）
- 会议会不会太慢？

**解决方案**：
- 会议**不需要**快速响应
- 会议是持续协商过程，可以跨越几小时甚至几天
- Agent异步参与，不需要同时在线

**设计理念**：
> "会议是邮件讨论链，不是即时聊天"

**类比**：
- GitHub Issue讨论（异步，可跨天）
- Slack聊天（同步，实时）
- AgentTalk会议 = GitHub风格

---

### 矛盾5：资源协调问题 ✅ 已解决

**原问题**：
- 后端专家如何找到数据库专家？
- 经理如何判断转发给谁？

**解决方案**：
- 三层路由架构
- LLM智能分析
- 经理作为"服务注册中心"

**服务发现机制**：
```
数据库专家注册：
  - 向技术经理注册
  - 声明标签：["数据库", "SQL", "数据建模"]

技术经理维护：
  - 所有技术专家的能力清单
  - LLM分析求助，匹配最佳专家

路由决策：
  - 输入：求助内容 + 标签
  - 处理：LLM分析
  - 输出：目标专家ID
```

---

## 七、设计的优势

### 7.1 清晰的职责边界

| 角色 | 职责 | 权限 |
|------|------|------|
| **专家** | 执行任务、发现问题 | 求助、汇报 |
| **经理** | 路由、协调、分配 | 召集会议、分配任务、转发求助 |
| **总经理** | 全局协调、跨部门路由 | 召集无标签会议、分配无标签任务 |

**核心原则**：
> 专家做事，经理协调，全局统筹

---

### 7.2 高效的通信路径

**路径长度分析**：

| 场景 | 路径 | 跳数 |
|------|------|------|
| 简单协作 | 后端→技术经理→数据库 | 2跳 |
| 部门内协作 | 后端→技术经理→前端→技术经理→后端 | 4跳 |
| 跨部门协作 | 后端→技术经理→总经理→产品经理→UI专家 | 4跳 |
| 复杂协作 | 专家→经理→总经理→经理→专家→经理→原专家 | 6跳 |

**优化设计**：
- 大部分协作在2跳内完成
- 跨部门协作在4跳内完成
- 经理层作为"缓存"，减少向上汇报

---

### 7.3 强大的扩展性

**添加新专家**：
```
1. 创建新的Agent实例
2. 向对应经理注册
3. 声明能力和标签
4. 立即可用
```

**添加新经理**：
```
1. 创建新的经理Agent
2. 向总经理注册
3. 声明负责的标签
4. 总经理的路由表自动更新
```

**添加新技能**：
```
1. 在Agent的profile中添加技能
2. 权限自动生效
3. 无需修改核心代码
```

---

### 7.4 符合人类组织模式

**类比公司架构**：
```
总经理         = CEO
项目经理       = 项目经理（PM）
技术经理       = 技术总监（CTO）
产品经理       = 产品总监（CPO）
后端专家       = 后端工程师
数据库专家     = DBA
```

**符合直觉**：
- 任何有管理经验的人都能理解
- 不需要学习新概念
- 容易向用户解释

---

## 八、待设计细节（后续阶段）

### 8.1 会议详细流程
- 会议邀请的详细格式
- 会议状态的转换规则
- 会议超时和终止机制
- 会议冲突的处理方式

### 8.2 监控机制细节
- 项目经理问询的触发条件
- 进度汇报的格式
- 超时检测的阈值
- 异常处理流程

### 8.3 消息协议细节
- 完整的消息类型定义
- 每种消息的字段要求
- 消息验证规则
- 错误处理机制

### 8.4 状态机设计
- 任务状态机
- 会议状态机
- Agent状态机
- 状态转换的触发条件

### 8.5 错误场景处理
- Agent失效的检测和恢复
- 消息丢失的检测和重发
- 任务失败的恢复机制
- 用户需求变更的处理

---

## 九、设计原则总结

### 原则1：权限固定，通过技能体现
- 不动态学习权限
- 权限 = 技能组合
- 清晰的权限边界

### 原则2：求助而非分配
- 专家向上求助
- 经理向下分配
- 清晰的职责边界

### 原则3：三层路由
- 专家层（执行）
- 经理层（路由）
- 总经理层（全局）

### 原则4：异步优先
- 会议不需要实时
- 允许延迟响应
- 支持离线参与

### 原则5：LLM智能决策
- LLM分析求助内容
- LLM判断路由方向
- LLM匹配最佳资源

### 原则6：可扩展性优先
- 添加Agent无需修改核心
- 声明式配置
- 插件化技能

---

## 十、下一步工作

### Phase 1: 继续完善需求
- [ ] 详细设计会议流程
- [ ] 定义监控机制
- [ ] 设计错误处理场景
- [ ] 明确状态机规则

### Phase 2: 技术设计
- [ ] 设计数据结构
- [ ] 定义通信协议
- [ ] 设计LLM提示词
- [ ] 设计存储方案

### Phase 3: MVP实现
- [ ] 实现3-5个Agent
- [ ] 实现核心功能
- [ ] 快速验证设计
- [ ] 收集反馈迭代

---

**文档版本**：v1.0
**创建日期**：2025-01-05
**最后更新**：2025-01-05

**状态**：✅ 核心设计决策已澄清，逻辑自洽性已验证
